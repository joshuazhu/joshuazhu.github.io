<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>web全栈工程师自我修养 3 软件设计方法</title><link rel="stylesheet" href="/css/layout.css" type="text/css">
<link rel="stylesheet" href="/css/main.css" type="text/css"><link rel="shortcut icon" href="/img/favicon.png"></head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Josh ZHU</a></li><li class="menu-item"><a href="/Categories" class="menu-link">Categories</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Josh ZHU</a></li><li class="menu-item"><a href="/Categories" class="menu-link">Categories</a></li></ul></nav><div id="mobile-menu-toggle" class="toggle-menu"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">web全栈工程师自我修养 3 软件设计方法</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title">发表于: </span>2016-04-25</p><p class="meta-item meta-category"><span class="meta-item-title">分类于: </span><a href="/categories/Self-improvement/" target="_blank" class="category-link">Self improvement</a></p></div><div class="article-content"><h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h1><h2 id="1-1-创建型模式"><a href="#1-1-创建型模式" class="headerlink" title="1.1 创建型模式"></a>1.1 创建型模式</h2><ol>
<li>对实例化过程进行了抽象。</li>
<li>对对象的创建过程进行了封装，客户程序不需要关心创建对象中的逻辑。</li>
<li>单例模式，工厂方法，抽象工厂， 建造模式，原型模式，对象池模式，多例模式。</li>
</ol>
<h2 id="1-2-结构型模式"><a href="#1-2-结构型模式" class="headerlink" title="1.2 结构型模式"></a>1.2 结构型模式</h2><ol>
<li>解决类，对象，模块之间的耦合关系。</li>
<li>适配器模式，桥接模式，组合模式，装饰模式，外观模式，享元模式和代理模式。</li>
</ol>
<h2 id="1-3-行为型模式"><a href="#1-3-行为型模式" class="headerlink" title="1.3 行为型模式"></a>1.3 行为型模式</h2><ol>
<li>用来识别对象之间的常用交流模式加以实现。</li>
<li>比如观察者模式： 一个目标对象管理者所有依赖它的观察者对象，并且在它本身状态改变时主动发出通知。</li>
<li>黑板，责任链， 命令，解释器，迭代器，中介者，备忘录，空对象，模板方法和访问者。</li>
</ol>
<h1 id="2-架构模式"><a href="#2-架构模式" class="headerlink" title="2. 架构模式"></a>2. 架构模式</h1><h2 id="2-1-MVC模式"><a href="#2-1-MVC模式" class="headerlink" title="2.1 MVC模式"></a>2.1 MVC模式</h2><ol>
<li>Model-View-Controller</li>
</ol>
<h1 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="3. 设计原则"></a>3. 设计原则</h1><h2 id="3-1-DRY-（Dont-Repeat-Yourself）"><a href="#3-1-DRY-（Dont-Repeat-Yourself）" class="headerlink" title="3.1 DRY （Dont Repeat Yourself）"></a>3.1 DRY （Dont Repeat Yourself）</h2><p>对于任何数据或者变量，都应该配置在有且只有一个地方，其他的地方都应该引用这里的数据。这样，需要改动数据的时候，只需要调整这一处，所有的地方修改都会变更过来。</p>
<h3 id="3-2-三次法则（Rule-of-three）"><a href="#3-2-三次法则（Rule-of-three）" class="headerlink" title="3.2 三次法则（Rule of three）"></a>3.2 三次法则（Rule of three）</h3><p>如果相同的代码片段重复三次以上，就需要将其提取出来做一个子程序。</p>
<h3 id="3-3-惯例由于配置-（Convention-Over-Configuration）"><a href="#3-3-惯例由于配置-（Convention-Over-Configuration）" class="headerlink" title="3.3 惯例由于配置 （Convention Over Configuration）"></a>3.3 惯例由于配置 （Convention Over Configuration）</h3><p>开发人员仅需规定应用中不符约定的部分。 例如如果名为Sale的Model对应的DB表名为sale作为约定，那么只需要把所有不符合这一约定（e.g. 表名为products_sold）写入相关的配置。</p>
<h3 id="3-4-KISS原则（Keep-it-simple，-stupid）"><a href="#3-4-KISS原则（Keep-it-simple，-stupid）" class="headerlink" title="3.4 KISS原则（Keep it simple， stupid）"></a>3.4 KISS原则（Keep it simple， stupid）</h3><ol>
<li>大部分系统的设计应该遵循简单原则，有不必要的复杂性就都应该避免。</li>
<li>如果一个系统非常复杂，应该分解为多个简单的组件，做好足够的分解和抽象。</li>
<li>简单系统的好处<br> a. 容易构造、维护和运行<br> b. 系统具有弹性和柔性<br> c. 系统更便宜<br> d. 更柔已实现.<br> e. 更容易分阶段执行.<br> f. 更容易理解</li>
</ol>
<h3 id="3-5-最少知道原则-Least-Knowledge-Principle"><a href="#3-5-最少知道原则-Least-Knowledge-Principle" class="headerlink" title="3.5 最少知道原则 (Least Knowledge Principle)"></a>3.5 最少知道原则 (Least Knowledge Principle)</h3><p>“松耦合原则”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#27599;&#19968;&#20010;&#21333;&#20803;&#37117;&#24212;&#35813;&#21482;&#30693;&#36947;&#20851;&#20110;&#20854;&#20182;&#21333;&#20803;&#30340;&#26377;&#38480;&#20449;&#24687;&#65306;&#37027;&#20123;&#19982;&#33258;&#24049;&#23494;&#20999;&#30456;&#20851;&#30340;&#21333;&#20803;&#12290;&#27599;&#19968;&#20010;&#21333;&#20803;&#24212;&#35813;&#21644;&#33258;&#24049;&#30340;&#26379;&#21451;&#35828;&#35805;&#65292;&#19981;&#21644;&#38476;&#29983;&#20154;&#35828;&#35805;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>对象都暴露少数对外的API， 而隐藏了自己的内部结构和实现原理。类在重构的时候，只需要保持API不变。</p>
</div></article><div id="base-discus"></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>Josh ZHU Using </span><a href="https://github.com/chuguixin/Simple"><span>Simple</span></a><span> Presents For You.</span></div></footer><div class="dom-ready"><script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js" type="text/javascript"></script><script src="/js/base.js" type="text/javascript"></script></div></body></html>